import{_ as d,M as s,p as r,q as n,R as a,N as h,V as i,t as e,a1 as t}from"./framework-5866ffd3.js";const c="/images/memcache-base.png",o={},u=a("h1",{id:"数据库",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#数据库","aria-hidden":"true"},"#"),e(" 数据库")],-1),_=a("blockquote",null,[a("p",null,"todo")],-1),p={class:"table-of-contents"},m=t('<h2 id="_1-sql通用知识" tabindex="-1"><a class="header-anchor" href="#_1-sql通用知识" aria-hidden="true">#</a> 1 SQL通用知识</h2><h2 id="_2-关系型数据库" tabindex="-1"><a class="header-anchor" href="#_2-关系型数据库" aria-hidden="true">#</a> 2 关系型数据库</h2><h3 id="_2-1-mysql" tabindex="-1"><a class="header-anchor" href="#_2-1-mysql" aria-hidden="true">#</a> 2.1 MySQL</h3><h2 id="_3-非关系型数据库" tabindex="-1"><a class="header-anchor" href="#_3-非关系型数据库" aria-hidden="true">#</a> 3 非关系型数据库</h2><h3 id="_3-1-redis" tabindex="-1"><a class="header-anchor" href="#_3-1-redis" aria-hidden="true">#</a> 3.1 Redis</h3><h4 id="持久化机制" tabindex="-1"><a class="header-anchor" href="#持久化机制" aria-hidden="true">#</a> 持久化机制</h4><p>Redis的持久化机制主要有两种：RDB和AOF。</p><h4 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB</h4><p>Redis DataBase，Redis的快照，将内存中的数据以二进制的形式保存到磁盘中。RDB的优点是恢复速度快，缺点是数据丢失的可能性大。</p><p>RDB持久化，是指在固定单位时间间隔内将内存中的数据集快照写入磁盘，以便在系统重启时，可以通过读取这个快照文件来恢复数据集。实际操作过程是 fork一个子进程，先将数据集写入临时文件，然后再用这个临时文件替换上次保存的快照文件，最后删除临时文件。用二进制压缩存储。</p><p>优点：</p><ul><li><p>只有一个备份文件，对于灾难恢复而言，数据恢复快，并且我们可以压缩存储到其他的介质上</p></li><li><p>速度快，对于Redis服务进程而言，在开始持久化，只需要fork出一个子线程，其余事情，子线程完成，极大避免服务进程进行IO耗时操作</p></li></ul><p>缺点：</p><ul><li></li></ul><h4 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF</h4><p>Append Only File，将Redis的所有写操作记录到一个日志文件中。AOF的优点是数据丢失的可能性小，缺点是恢复速度慢。</p><p>AOF持久化，是指在每次执行写操作时，将这个写操作追加到AOF文件的末尾。当Redis重启时，会重新执行AOF文件中的所有写操作来恢复数据集。用文本格式存储。</p><h3 id="_3-2-memcache" tabindex="-1"><a class="header-anchor" href="#_3-2-memcache" aria-hidden="true">#</a> 3.2 memcache</h3><p>memcache是一个纯内存的k-v存储，其数据都放入内存中。当内存不够时，会使用LRU算法淘汰数据。memcache的数据是不持久化的，当服务重启时，数据会丢失。 主要关键点：</p><ul><li><p>访问数据比较快，因为数据都在内存中，而且数据都是以key-value的形式存储的，所以访问数据的速度非常快。传统的关系型数据库IO耗时；</p></li><li><p>数据存储在内存，memcache重启，则数据丢失；</p></li><li><p>存储在内存中，会受到机器位数的限制，32位机器最大只能存储2G数据，64位机器可以认为没有限制。</p></li></ul><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h4><p><img src="'+c+'" alt="memcache内存图"></p><p>上面的图中主要涉及了四个概念：slab_class、slab、page、chunk。</p><ul><li><p>memcache将内存分为一组slab</p></li><li><p>每个slab下有若干个page，每个page的大小是固定的，默认为1M</p></li><li><p>每个page下有若干个chunk，chunk是真正存放数据的地方，每个chunk的大小是固定的</p></li><li><p>有相同大小的chunk被slab组织在一起，称为slab_class</p></li></ul><h4 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h4><p>变化频繁的，具有不稳定性的数据，不需要实时入库（如：用户在线状态、在线人数）门户网站的新闻等，可以使用memcache来缓存数据，减轻数据库的压力。</p><h3 id="_3-3-mongodb" tabindex="-1"><a class="header-anchor" href="#_3-3-mongodb" aria-hidden="true">#</a> 3.3 MongoDB</h3><h3 id="_3-4-hbase" tabindex="-1"><a class="header-anchor" href="#_3-4-hbase" aria-hidden="true">#</a> 3.4 HBase</h3><h3 id="_3-5-pegasus" tabindex="-1"><a class="header-anchor" href="#_3-5-pegasus" aria-hidden="true">#</a> 3.5 Pegasus</h3>',29);function f(b,x){const l=s("router-link");return r(),n("div",null,[u,_,a("nav",p,[a("ul",null,[a("li",null,[h(l,{to:"#_1-sql通用知识"},{default:i(()=>[e("1 SQL通用知识")]),_:1})]),a("li",null,[h(l,{to:"#_2-关系型数据库"},{default:i(()=>[e("2 关系型数据库")]),_:1}),a("ul",null,[a("li",null,[h(l,{to:"#_2-1-mysql"},{default:i(()=>[e("2.1 MySQL")]),_:1})])])]),a("li",null,[h(l,{to:"#_3-非关系型数据库"},{default:i(()=>[e("3 非关系型数据库")]),_:1}),a("ul",null,[a("li",null,[h(l,{to:"#_3-1-redis"},{default:i(()=>[e("3.1 Redis")]),_:1})]),a("li",null,[h(l,{to:"#_3-2-memcache"},{default:i(()=>[e("3.2 memcache")]),_:1})]),a("li",null,[h(l,{to:"#_3-3-mongodb"},{default:i(()=>[e("3.3 MongoDB")]),_:1})]),a("li",null,[h(l,{to:"#_3-4-hbase"},{default:i(()=>[e("3.4 HBase")]),_:1})]),a("li",null,[h(l,{to:"#_3-5-pegasus"},{default:i(()=>[e("3.5 Pegasus")]),_:1})])])])])]),m])}const k=d(o,[["render",f],["__file","database.html.vue"]]);export{k as default};
