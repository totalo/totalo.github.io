# 基础

> todo

[[TOC]]

## 1. 基础

### 1.1 语法

#### <u>关于面向对象</u>

面相对象是一种思想，世间万物都可以看成是对象。当让对于变成来说，主要强调的是面向对象编程（OOP），
Java 是面向对象的编程语言，而面向对象主要的好处如下：

- 开发模块化，更容易维护和修改
- 代码复用性强
- 增强代码的灵活性和可靠性
- 增加代码的可读性

**1）面相对象的基本特征如下：**

a、封装

主要是给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。
在 Java 中提供了 4 种权限访问符：`public`、`protected`、`default`、`private`，每一个修饰符给同一包
或者不同包下的对象提供不同的访问权限。具体的访问权限如下：

|  控制符   | 本类 |  同包  |  子类  | 任意位置 |
| :-------: | :--: | :----: | :----: | :------: |
|  public   | 可以 |  可以  |  可以  |   可以   |
| protected | 可以 |  可以  |  可以  |  不可以  |
|  default  | 可以 |  可以  | 不可以 |  不可以  |
|  private  | 可以 | 不可以 | 不可以 |  不可以  |

通过使用封装，存在如下的一些好处：

- 通过隐藏对象的属性来保护对象的内部状态。

- 提高了代码的可用性和维护下，对象的行为可以被单独的改变或者拓展。

- 禁止了对象之间的不良交互，提高模块化。

b、继承

继承实现的是 IS-A 的关系，给对象提供了从基类获取字段和方法的能力，提供了代码的重用性，可以在不修改类的情况下给类添加新特性。

c、多态

多态分为编译时和运行时多态，运行多态要满足3个条件：继承、重写（覆盖）、向上转型

- 编译时多态主要指的是方法的重载
- 运行时多态是指程序中定义的对象引用所指的类型在运行时才能确定。

**2）面向过程和面向对象的区别：**

- 面向过程
  - 优点：性能比面向对象高，类调用需要实例化，开销大，比较消耗资源。
  - 缺点：没有面向对象易维护、易复用、易拓展
- 面向对象：
  - 优点：易维护、易复用、易拓展，由于面向对象的封装、继承、多态等特性，可以设计出低耦合系统，使系统更加灵活易于维护。
  - 缺点：性能比面向过程低。

**3）重载和重写的区别**

- 重写（Override）
  - 方法名、参数、返回值不同
  - 子类方法不能缩小父类方法的访问权限
  - 子类方法不能抛出比父类更多的异常（子类可以不抛出）
  - 存在于父子类之间
  - 方法被定义为`final`不能被重写

- 重载（Overload）
  - 参数类型、个数、顺序至少有一个不相同
  - 不能重载只有返回值不同的方法名（原因在于编译器没办法判断出调用方法的类型。如 使用int x = f()是可以判断的，但是f()没办法确认调用的方法，所以是不能重载的）
  - 存在于父类、子类和同类中

#### <u>Java数据类型</u>

**1）基本数据类型**

- 整数值型：**byte**(1 byte)、**short**(2 byte)、**int**(4 byte)、**long**(8 byte)
- 字符型：**char**(2 byte)
- 浮点类型：**float**(4 byte)、**double**(8 byte)
- 布尔型：**boolean**(1 byte)

**2）引用类型**

变量在内存中实际存储的是一个引用地址，实体在堆中，主要包括：类、接口、数组等，特别的String不是基本数据类型。

**关于值传递和引用传递**

- 值传递：对于基本类型而言，传递的是该变量的一个副本，改变副本不影响原变量。
- 引用传递：对于对象型而言，传递的是该对象地址的副本，而不是对象的本身。

一般认为，Java内基本类型传递都是值传递，而示例对象传递是引用传递。

#### <u>equals和hashcode的理解</u>

- 基本机制

两个对象`hashcode()`不相等，则`equals()`必不相等，`equals()`相等则`hashCode()` 一定相等。

- 为什么重写 `equals`  方法的时候需要重写 `hashCode` 方法?

规范强制规定重写`equals`方法时，必须同事重写`hashCode`方法。许多容器类，如`HashMap`、`HashSet`会依赖于对象的`equals`和`hashCode`方法判断是否同一个对象。

#### <u>String str = new String("abc")会创建几个对象？</u>

若在 String 池内找到 abc，则不会创建，若没找到，则创建一个对象，new 关键字会在内存上创建一个对象，并返回给str。总共是 **1 个或者 2 个。**

#### <u>final、finally、finalize的区别</u>

- final

修饰符关键字，如果一个类被声明为 final ，意味着它不能派生新的子类，不能作为父类被继承，因此一个类不能被同时声明为 abstract 和 final ;将变量和方法声明为 final 可以保证其在使用时不被改变值，被声明为final的变量在必须在声明时初始化，而在以后的引用中只能读取，不可修改，声明为final的方法，同样只能使用，不能被重写。

- finally

异常处理提供的一个后置处理的代码块模块。一般都会执行，但是如下四种情况finally不会执行：1）在 finally 块中发生了异常；2） finally 代码块前执行了 System.exit() 方法；3）程序所在的线程死亡；4）关闭 CPU 

- finalize

一个方法名，Java允许使用 finalize() 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，这个方法是由垃圾收集器在确定这个对象没有被引用。

#### <u>**String、StringBuffer、StringBuilder区别**</u>

- String 是 final class，所有属性也是 final  的，是不可变的，类似拼接、裁剪字符串都会产生新的 String  对象。由于字符串操作的普遍性，所以相关的操作的效率往往对应用性能有明显影响。

- StringBuffer 是一个线程安全的可修改字符序列，保证了线程安全，也随之而来带来了额外的性能开销，所以除非有线程安全的需要。
- StringBuilder 本质上和 StringBuffer 无主要区别，但是去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。（JDK1.5添加）

#### <u>接口和抽象类的区别</u>

从设计层面，抽象是对类的抽象，是一种模版设计，接口是行为的抽象，更像是一种行为规范。

- 一个类只能继承一个抽象类，但是能实现多个接口
- 抽象类可以有构造方法，接口没有构造方法
- 抽象类可以有普通的成员变量，接口没有普通成员变量
- 抽象类和接口都可以有静态成员变量，抽象类中的静态成员变量访问任意类型，接口只能 public static final （默认）
- 抽象类可以没有抽象方法，可以有普通方法，接口在 JDK8 之前都是抽象方法，在 JDK8 有 default 方法，JDK9 中允许有私有普通方法
- 抽象类可以有静态方法，接口在 JDK8之前不允许有静态方法，在 JDK8 运行有静态方法，但是只能被接口类调用（不能被实现类调用）
- 抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法

#### <u>类的实例化顺序</u>

1. 父类静态变量
2. 父类静态代码块
3. 子类静态变量
4. 子类静态代码块
5. 父类非静态变量
6. 父类构造函数
7. 子类非静态变量
8. 子类构造函数

### 1.2 反射

#### <u>什么是反射？</u>

反射就是Reflection，Java的反射指程序在运行期间可以拿到一个对象的所有信息。

#### <u>主要功能</u>

- 在运行时构造一个类对象
- 判断一个类所具有的成员变量和方法
- 调用对象的方法
- 生成动态代理

应用：

Spring 框架的IoC基于反射创建对象和依赖属性

Spring MVC的请求调用对应的方法

JDBC的`Class.forName`方法

#### <u>Class.forName和ClassLoader的区别</u>

Class.forName 除了将 class 文件加载至 JVM 以外，还会将类进行解释，执行类的 static 块；

ClassLoader只会将class文件加载至 JVM ，只有在 newInstance 才会执行 static 块。

#### <u>动态代理和静态代理</u>

- **动态代理和静态代理的区别**

静态：由程序员创建代理累或者由特定的工具生成源代码，对其进行编译。此方式每个代理类只能对应一个被代理的对象。

动态：在程序运行时运用反射机制动态创建而成。此方式是一个通用的。（在程序运行期间，创建目标的代理对象，并对目标对象中的方法进行功能性增加的一种技术。）

- **动态代理的原理**

主要分为两种：JDK动态代理和GCLIB动态代理。

JDK动态代理：只能对实现了**接口**的类生成代理，而不能针对类

CGLIB动态代理：对类实现代理，主要是对制定的类生成一个子类，覆盖其中的方法。因为是**继承**，所以该类或方法不能声明为final 以及private.

spring AOP的动态代理分为spring framwork为jdk动态代理而spring boot 2.x以上为cglib动态代理，修改为jdk动态代理，spring-aop-proxy-target-class=false。

- **性能对比**

  - jdk6 下，在运行次数较少的情况下，jdk动态代理与 cglib 差距不明显，甚至更快一些；而当调用次数增加之后， cglib 表现稍微更快一些

  - jdk7 下，情况发生了逆转！在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍

  - jdk8 表现和 jdk7 基本一致

#### <u>getName、getCanonicalName与getSimpleName的区别?</u>

- getSimpleName：只获取类名
- getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。
- getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。

```java
public static void main(String[] args) {
  System.out.println(Inner.class.getSimpleName()); // Inner
  System.out.println(Inner.class.getName()); // top.totalo.Test$Inner  若非内部类，则两者展现的效果相同
  System.out.println(Inner.class.getCanonicalName()); // // top.totalo.Test.Inner 
}
    
class Inner {
        
}
```



### 1.3 泛型
### 1.4 异常
### 1.5 注解
### 1.6 SPI机制
## 2. 集合
## 3. IO
## 4. 多线程与并发
## 5. JVM
## 6. 版本特性
## 7. 开发工具