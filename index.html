<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.61">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="stylesheet" href="/css/index.css"><meta name="application-name" content="totalo's blog"><meta name="apple-mobile-web-app-title" content="totalo's blog"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png"><link rel="mask-icon" href="/images/icons/safari-pinned-tab.svg" color="#3eaf7c"><meta name="msapplication-TileColor" content="#3eaf7c"><meta name="theme-color" content="#3eaf7c"><meta name="baidu_union_verify" content="a00b76ff410da1d7f3767aef6ec7297c"><meta name="google-site-verification" content="HJSuC0Hl5NSGNNBxkBM9Ls9yV_KrkQwRbJcACTEoyps"><script crossorigin="anonymous" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4545022751103525"></script><script>
        var _hmt = _hmt || [];
        (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e58acf9806e55ac523ba77b5a273de3b";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
        })();
        </script><title>Redis | Hello World</title><meta name="description" content="摆摊写代码totalo得小破站">
    <link rel="preload" href="/assets/style-d2355f92.css" as="style"><link rel="stylesheet" href="/assets/style-d2355f92.css">
    <link rel="modulepreload" href="/assets/app-51ae8744.js"><link rel="modulepreload" href="/assets/framework-5866ffd3.js"><link rel="modulepreload" href="/assets/index.html-1cb3ba61.js"><link rel="modulepreload" href="/assets/index.html-a1bedd3e.js"><link rel="prefetch" href="/assets/code-base.html-011b4559.js" as="script"><link rel="prefetch" href="/assets/java.html-c7312f65.js" as="script"><link rel="prefetch" href="/assets/middleware.html-367e880a.js" as="script"><link rel="prefetch" href="/assets/system-design.html-088a4bc1.js" as="script"><link rel="prefetch" href="/assets/index.html-d2a1f749.js" as="script"><link rel="prefetch" href="/assets/index.html-c41e1210.js" as="script"><link rel="prefetch" href="/assets/best-practices.html-afc73b6b.js" as="script"><link rel="prefetch" href="/assets/base.html-c5ed2d3a.js" as="script"><link rel="prefetch" href="/assets/io.html-68d7bfd8.js" as="script"><link rel="prefetch" href="/assets/object.html-d243d09d.js" as="script"><link rel="prefetch" href="/assets/mysql.html-e48f3e2a.js" as="script"><link rel="prefetch" href="/assets/algorithms.html-3e81f5ac.js" as="script"><link rel="prefetch" href="/assets/database.html-30650d5d.js" as="script"><link rel="prefetch" href="/assets/design-mode.html-e456b9ab.js" as="script"><link rel="prefetch" href="/assets/java.html-9b9c4ba1.js" as="script"><link rel="prefetch" href="/assets/middleware.html-fb8e122f.js" as="script"><link rel="prefetch" href="/assets/others.html-9394554b.js" as="script"><link rel="prefetch" href="/assets/system-design.html-605d9c58.js" as="script"><link rel="prefetch" href="/assets/system-network.html-27bb8aa6.js" as="script"><link rel="prefetch" href="/assets/system.html-3ac080ee.js" as="script"><link rel="prefetch" href="/assets/log4j-deadlock.html-3610caa5.js" as="script"><link rel="prefetch" href="/assets/spring.html-80aa9998.js" as="script"><link rel="prefetch" href="/assets/sort.html-df3a85b5.js" as="script"><link rel="prefetch" href="/assets/annotation.html-515fc352.js" as="script"><link rel="prefetch" href="/assets/base.html-3148e9ec.js" as="script"><link rel="prefetch" href="/assets/exception.html-1888ab9c.js" as="script"><link rel="prefetch" href="/assets/generics.html-99e79276.js" as="script"><link rel="prefetch" href="/assets/object.html-bcf09279.js" as="script"><link rel="prefetch" href="/assets/reflection.html-167ec82a.js" as="script"><link rel="prefetch" href="/assets/spi.html-607858ba.js" as="script"><link rel="prefetch" href="/assets/collection.html-c2497509.js" as="script"><link rel="prefetch" href="/assets/concurrency.html-c6d156f6.js" as="script"><link rel="prefetch" href="/assets/io.html-c5ce71e5.js" as="script"><link rel="prefetch" href="/assets/jvm.html-cecf1aff.js" as="script"><link rel="prefetch" href="/assets/rocketmq.html-5f7157cb.js" as="script"><link rel="prefetch" href="/assets/shardingsphere.html-3a628d1d.js" as="script"><link rel="prefetch" href="/assets/thrift.html-420b2d3b.js" as="script"><link rel="prefetch" href="/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/assets/code-base.html-1feab355.js" as="script"><link rel="prefetch" href="/assets/java.html-3b1774d7.js" as="script"><link rel="prefetch" href="/assets/middleware.html-b6b676e5.js" as="script"><link rel="prefetch" href="/assets/system-design.html-6558da07.js" as="script"><link rel="prefetch" href="/assets/index.html-406602c2.js" as="script"><link rel="prefetch" href="/assets/index.html-8c9668d9.js" as="script"><link rel="prefetch" href="/assets/best-practices.html-e2c81785.js" as="script"><link rel="prefetch" href="/assets/base.html-17631ee8.js" as="script"><link rel="prefetch" href="/assets/io.html-b9ff4253.js" as="script"><link rel="prefetch" href="/assets/object.html-dde8116e.js" as="script"><link rel="prefetch" href="/assets/mysql.html-f7950644.js" as="script"><link rel="prefetch" href="/assets/algorithms.html-39d7a27d.js" as="script"><link rel="prefetch" href="/assets/database.html-a8d6c758.js" as="script"><link rel="prefetch" href="/assets/design-mode.html-b5658189.js" as="script"><link rel="prefetch" href="/assets/java.html-6824bc50.js" as="script"><link rel="prefetch" href="/assets/middleware.html-309760f8.js" as="script"><link rel="prefetch" href="/assets/others.html-af4d5bd3.js" as="script"><link rel="prefetch" href="/assets/system-design.html-e19994b2.js" as="script"><link rel="prefetch" href="/assets/system-network.html-7792a950.js" as="script"><link rel="prefetch" href="/assets/system.html-0405515b.js" as="script"><link rel="prefetch" href="/assets/log4j-deadlock.html-f340eabe.js" as="script"><link rel="prefetch" href="/assets/spring.html-df1b0704.js" as="script"><link rel="prefetch" href="/assets/sort.html-c26231ea.js" as="script"><link rel="prefetch" href="/assets/annotation.html-9a14fd79.js" as="script"><link rel="prefetch" href="/assets/base.html-ca8815a8.js" as="script"><link rel="prefetch" href="/assets/exception.html-258e9e63.js" as="script"><link rel="prefetch" href="/assets/generics.html-a26630ec.js" as="script"><link rel="prefetch" href="/assets/object.html-55632497.js" as="script"><link rel="prefetch" href="/assets/reflection.html-45c9d0d2.js" as="script"><link rel="prefetch" href="/assets/spi.html-9455e502.js" as="script"><link rel="prefetch" href="/assets/collection.html-3e7e53ba.js" as="script"><link rel="prefetch" href="/assets/concurrency.html-a14e00c4.js" as="script"><link rel="prefetch" href="/assets/io.html-c1de3fb8.js" as="script"><link rel="prefetch" href="/assets/jvm.html-9e8f2275.js" as="script"><link rel="prefetch" href="/assets/rocketmq.html-3e7eb0a5.js" as="script"><link rel="prefetch" href="/assets/shardingsphere.html-3b336d11.js" as="script"><link rel="prefetch" href="/assets/thrift.html-4561e009.js" as="script"><link rel="prefetch" href="/assets/404.html-87d54bd8.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a aria-current="page" href="/" class="router-link-active router-link-exact-active"><!----><span class="site-name">Hello World</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>关系型数据库</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/database/mysql.html" class="" aria-label="MySQL"><!--[--><!--]--> MySQL <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>NoSQL</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/database/README.md" class="" aria-label="/zh/database/README.md"><!--[--><!--]--> /zh/database/README.md <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a href="/zh/problems/log4j-deadlock.md" class="" aria-label="踩的坑"><!--[--><!--]--> 踩的坑 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/zh/best-practices.md" class="" aria-label="各种最佳实践"><!--[--><!--]--> 各种最佳实践 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java面向对象体系和基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/base/object.html" class="" aria-label="面向对象"><!--[--><!--]--> 面向对象 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/zh/java/base/base.html" class="" aria-label="语法基础"><!--[--><!--]--> 语法基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - 集合框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/collection/collection.html" class="" aria-label="集合"><!--[--><!--]--> 集合 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - IO框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/io/io.html" class="" aria-label="IO"><!--[--><!--]--> IO <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - 多线程与并发</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/concurrency/concurrency.html" class="" aria-label="多线程与并发"><!--[--><!--]--> 多线程与并发 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - JVM与程序调优</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/jvm/jvm.html" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Go"><span class="title">Go</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Go"><span class="title">Go</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Spring体系"><span class="title">Spring体系</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Spring体系"><span class="title">Spring体系</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Spring</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/spring/spring.html" class="" aria-label="Spring 源码解析"><!--[--><!--]--> Spring 源码解析 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="分布式"><span class="title">分布式</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="分布式"><span class="title">分布式</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>算法基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/algo/base/sort.html" class="" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="中间件"><span class="title">中间件</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="中间件"><span class="title">中间件</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Shardingsphere</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/middleware/shardingsphere/shardingsphere.html" class="" aria-label="Shardingsphere"><!--[--><!--]--> Shardingsphere <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><a href="/zh/middleware/rocketmq/rocketmq.md" class="" aria-label="RocketMQ"><!--[--><!--]--> RocketMQ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/zh/middleware/thrift/thrift.md" class="" aria-label="Thrift"><!--[--><!--]--> Thrift <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="选择语言"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="选择语言"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/en/" class="" aria-label="en-US"><!--[--><!--]--> en-US <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/" class="router-link-active router-link-exact-active" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/totalo/website" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="切换颜色模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>关系型数据库</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/database/mysql.html" class="" aria-label="MySQL"><!--[--><!--]--> MySQL <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>NoSQL</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/database/README.md" class="" aria-label="/zh/database/README.md"><!--[--><!--]--> /zh/database/README.md <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a href="/zh/problems/log4j-deadlock.md" class="" aria-label="踩的坑"><!--[--><!--]--> 踩的坑 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/zh/best-practices.md" class="" aria-label="各种最佳实践"><!--[--><!--]--> 各种最佳实践 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java面向对象体系和基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/base/object.html" class="" aria-label="面向对象"><!--[--><!--]--> 面向对象 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/zh/java/base/base.html" class="" aria-label="语法基础"><!--[--><!--]--> 语法基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - 集合框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/collection/collection.html" class="" aria-label="集合"><!--[--><!--]--> 集合 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - IO框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/io/io.html" class="" aria-label="IO"><!--[--><!--]--> IO <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - 多线程与并发</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/concurrency/concurrency.html" class="" aria-label="多线程与并发"><!--[--><!--]--> 多线程与并发 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java进阶 - JVM与程序调优</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/java/jvm/jvm.html" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Go"><span class="title">Go</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Go"><span class="title">Go</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Spring体系"><span class="title">Spring体系</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Spring体系"><span class="title">Spring体系</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Spring</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/spring/spring.html" class="" aria-label="Spring 源码解析"><!--[--><!--]--> Spring 源码解析 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="分布式"><span class="title">分布式</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="分布式"><span class="title">分布式</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>算法基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/algo/base/sort.html" class="" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="中间件"><span class="title">中间件</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="中间件"><span class="title">中间件</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Shardingsphere</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/zh/middleware/shardingsphere/shardingsphere.html" class="" aria-label="Shardingsphere"><!--[--><!--]--> Shardingsphere <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><a href="/zh/middleware/rocketmq/rocketmq.md" class="" aria-label="RocketMQ"><!--[--><!--]--> RocketMQ <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/zh/middleware/thrift/thrift.md" class="" aria-label="Thrift"><!--[--><!--]--> Thrift <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="选择语言"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="选择语言"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/en/" class="" aria-label="en-US"><!--[--><!--]--> en-US <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/" class="router-link-active router-link-exact-active" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/totalo/website" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Redis <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/#基础数据结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础数据结构"><!--[--><!--]--> 基础数据结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/#一、redis-的数据结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、Redis 的数据结构"><!--[--><!--]--> 一、Redis 的数据结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#二、string-字符串" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、String（字符串）"><!--[--><!--]--> 二、String（字符串） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#三、list-列表" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、List（列表）"><!--[--><!--]--> 三、List（列表） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#三、hash" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、Hash"><!--[--><!--]--> 三、Hash <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#四、set-集合" class="router-link-active router-link-exact-active sidebar-item" aria-label="四、Set（集合）"><!--[--><!--]--> 四、Set（集合） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#五、zset-有序集合" class="router-link-active router-link-exact-active sidebar-item" aria-label="五、ZSet（有序集合）"><!--[--><!--]--> 五、ZSet（有序集合） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#六、bitmap-位图" class="router-link-active router-link-exact-active sidebar-item" aria-label="六、Bitmap（位图）"><!--[--><!--]--> 六、Bitmap（位图） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#七、hyperloglog" class="router-link-active router-link-exact-active sidebar-item" aria-label="七、HyperLogLog"><!--[--><!--]--> 七、HyperLogLog <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#八、geo" class="router-link-active router-link-exact-active sidebar-item" aria-label="八、GEO"><!--[--><!--]--> 八、GEO <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#九、stream" class="router-link-active router-link-exact-active sidebar-item" aria-label="九、Stream"><!--[--><!--]--> 九、Stream <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/#线程模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程模型"><!--[--><!--]--> 线程模型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/#一、消息处理流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、消息处理流程"><!--[--><!--]--> 一、消息处理流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#二、io多路复用的程序的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、IO多路复用的程序的实现"><!--[--><!--]--> 二、IO多路复用的程序的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#三、文件事件的类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、文件事件的类型"><!--[--><!--]--> 三、文件事件的类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#四、文件事件处理器" class="router-link-active router-link-exact-active sidebar-item" aria-label="四、文件事件处理器"><!--[--><!--]--> 四、文件事件处理器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#五、一次客户端和-redis-的通信流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="五、一次客户端和 redis 的通信流程"><!--[--><!--]--> 五、一次客户端和 redis 的通信流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/#性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/#一、linux-系统优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、Linux 系统优化"><!--[--><!--]--> 一、Linux 系统优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#二、redis-参数优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、Redis 参数优化"><!--[--><!--]--> 二、Redis 参数优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#四、慢查询语句" class="router-link-active router-link-exact-active sidebar-item" aria-label="四、慢查询语句"><!--[--><!--]--> 四、慢查询语句 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/#主从复制" class="router-link-active router-link-exact-active sidebar-item" aria-label="主从复制"><!--[--><!--]--> 主从复制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#cluster集群" class="router-link-active router-link-exact-active sidebar-item" aria-label="cluster集群"><!--[--><!--]--> cluster集群 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#持久化" class="router-link-active router-link-exact-active sidebar-item" aria-label="持久化"><!--[--><!--]--> 持久化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#事务机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="事务机制"><!--[--><!--]--> 事务机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#故障排查" class="router-link-active router-link-exact-active sidebar-item" aria-label="故障排查"><!--[--><!--]--> 故障排查 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#淘汰策略与缓存机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="淘汰策略与缓存机制"><!--[--><!--]--> 淘汰策略与缓存机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/#大key风险和改造" class="router-link-active router-link-exact-active sidebar-item" aria-label="大key风险和改造"><!--[--><!--]--> 大key风险和改造 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><nav class="table-of-contents"><ul><li><a aria-current="page" href="/#基础数据结构" class="router-link-active router-link-exact-active">基础数据结构</a><ul><li><a aria-current="page" href="/#一、redis-的数据结构" class="router-link-active router-link-exact-active">一、Redis 的数据结构</a></li><li><a aria-current="page" href="/#二、string-字符串" class="router-link-active router-link-exact-active">二、String（字符串）</a></li><li><a aria-current="page" href="/#三、list-列表" class="router-link-active router-link-exact-active">三、List（列表）</a></li><li><a aria-current="page" href="/#三、hash" class="router-link-active router-link-exact-active">三、Hash</a></li><li><a aria-current="page" href="/#四、set-集合" class="router-link-active router-link-exact-active">四、Set（集合）</a></li><li><a aria-current="page" href="/#五、zset-有序集合" class="router-link-active router-link-exact-active">五、ZSet（有序集合）</a></li><li><a aria-current="page" href="/#六、bitmap-位图" class="router-link-active router-link-exact-active">六、Bitmap（位图）</a></li><li><a aria-current="page" href="/#七、hyperloglog" class="router-link-active router-link-exact-active">七、HyperLogLog</a></li><li><a aria-current="page" href="/#八、geo" class="router-link-active router-link-exact-active">八、GEO</a></li><li><a aria-current="page" href="/#九、stream" class="router-link-active router-link-exact-active">九、Stream</a></li></ul></li><li><a aria-current="page" href="/#线程模型" class="router-link-active router-link-exact-active">线程模型</a><ul><li><a aria-current="page" href="/#一、消息处理流程" class="router-link-active router-link-exact-active">一、消息处理流程</a></li><li><a aria-current="page" href="/#二、io多路复用的程序的实现" class="router-link-active router-link-exact-active">二、IO多路复用的程序的实现</a></li><li><a aria-current="page" href="/#三、文件事件的类型" class="router-link-active router-link-exact-active">三、文件事件的类型</a></li><li><a aria-current="page" href="/#四、文件事件处理器" class="router-link-active router-link-exact-active">四、文件事件处理器</a></li><li><a aria-current="page" href="/#五、一次客户端和-redis-的通信流程" class="router-link-active router-link-exact-active">五、一次客户端和 redis 的通信流程</a></li></ul></li><li><a aria-current="page" href="/#性能优化" class="router-link-active router-link-exact-active">性能优化</a><ul><li><a aria-current="page" href="/#一、linux-系统优化" class="router-link-active router-link-exact-active">一、Linux 系统优化</a></li><li><a aria-current="page" href="/#二、redis-参数优化" class="router-link-active router-link-exact-active">二、Redis 参数优化</a></li><li><a aria-current="page" href="/#四、慢查询语句" class="router-link-active router-link-exact-active">四、慢查询语句</a></li></ul></li><li><a aria-current="page" href="/#主从复制" class="router-link-active router-link-exact-active">主从复制</a></li><li><a aria-current="page" href="/#cluster集群" class="router-link-active router-link-exact-active">cluster集群</a></li><li><a aria-current="page" href="/#持久化" class="router-link-active router-link-exact-active">持久化</a></li><li><a aria-current="page" href="/#事务机制" class="router-link-active router-link-exact-active">事务机制</a></li><li><a aria-current="page" href="/#故障排查" class="router-link-active router-link-exact-active">故障排查</a></li><li><a aria-current="page" href="/#淘汰策略与缓存机制" class="router-link-active router-link-exact-active">淘汰策略与缓存机制</a></li><li><a aria-current="page" href="/#大key风险和改造" class="router-link-active router-link-exact-active">大key风险和改造</a></li></ul></nav><h2 id="基础数据结构" tabindex="-1"><a class="header-anchor" href="#基础数据结构" aria-hidden="true">#</a> <strong>基础数据结构</strong></h2><h3 id="一、redis-的数据结构" tabindex="-1"><a class="header-anchor" href="#一、redis-的数据结构" aria-hidden="true">#</a> 一、<code>Redis</code> 的数据结构</h3><p>常见的五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p>后续新增：<strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong></p><blockquote><p>Redis操作命令参考：http://redisdoc.com/index.html</p></blockquote><h3 id="二、string-字符串" tabindex="-1"><a class="header-anchor" href="#二、string-字符串" aria-hidden="true">#</a> 二、<code>String</code>（字符串）</h3><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <strong>512M</strong></p><p>底层数据结构主要是<strong>int</strong> 和<strong>SDS（简单动态字符串）</strong>，是可以修改的字符串，内部的结构类似 <code>Java</code> 的 <code>ArrayList</code> , <strong>采用预分配冗余空间的方式减少内存的频繁分配。</strong></p><p>SDS相对c原生字符串的优势：</p><ul><li><p><strong>SDS不仅仅可以保存文本数据，还可以保存二进制数据</strong>：因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</p></li><li><p><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong>：因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</p></li><li><p><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>：因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</p></li></ul><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、raw和 embstr</strong>。</p><ul><li><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成 long），并将字符串对象的编码设置为<code>int</code>。</p></li><li><p>如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>embstr</code>， <code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式。</p></li><li><p>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>raw</code></p></li></ul><p>可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code></p><p><strong>优点：</strong></p><ul><li><p><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</p></li><li><p>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</p></li><li><p><code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</p></li></ul><p><strong>缺点：</strong></p><ul><li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</li></ul><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置键值对</span>
SET key value

<span class="token comment"># 获取键值对</span>
GET key

<span class="token comment"># 一次性获取多个键值对</span>
MGET key1 key2 <span class="token punctuation">..</span>.

<span class="token comment"># 一次设置多个键值对</span>
MSET key1 value1 key2 value2 <span class="token punctuation">..</span>

<span class="token comment"># 判断键是否存在</span>
EXISTS key

<span class="token comment"># 删除键值对</span>
DEL key1 key2 <span class="token punctuation">..</span>.

<span class="token comment"># 匹配对应的key，查找foo开头的key</span>
KEYS foo*

<span class="token comment"># 修改key的名称，若新名称存在，则报错</span>
REMANE key1 key2

<span class="token comment"># 返回key的总数</span>
DBSIZE

<span class="token comment"># 设置key的过期时间，单位秒</span>
EXPIRE key seconds

<span class="token comment"># 设置过期时间，等价于 set+expire</span>
SETEX key <span class="token function">time</span> value

<span class="token comment"># 如果 key 不存在则执行 set 创建，返回 1。否则不创建返回 0</span>
SETNX key value

<span class="token comment"># 前两个是递增 1 和递减 1 【INCR key】，后两个是指定递增和递减的数字【INCRBY KEY 倍数】。前提是一定要是数字才能进行加减；</span>
INCR/DECR/INCRBY/DECRBY
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p>（1）缓存对象</p><p>（2）常规计数</p><p>（3）分布式锁</p><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token operator">//</span> 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;del&quot;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三、list-列表" tabindex="-1"><a class="header-anchor" href="#三、list-列表" aria-hidden="true">#</a> 三、<code>List</code>（列表）</h3><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 <code>List</code> 列表添加元素。类似 <code>Java</code> 的 <code>LinkedList</code>。</p><p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素</p><p>底层实现<strong>双向链表或压缩列表</strong>实现的，如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</p><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p><p><strong>常用命令：</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span>
LPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span> 

<span class="token comment"># 将一个或多个值value插入到key列表的表尾(最右边)</span>
RPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 移除并返回key列表的头元素</span>
LPOP key     

<span class="token comment"># 移除并返回key列表的尾元素</span>
RPOP key 

<span class="token comment"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span>
LRANGE key start stop

<span class="token comment"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
BLPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>

<span class="token comment"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
BRPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><ul><li>消息队列</li></ul><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><p>(1) 如何满足消息保序需求？</p><p><code>List</code> 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 <code>List</code> 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p><code>List</code> 可以使用 <code>LPUSH</code> + <code>RPOP</code> （或者反过来，<code>RPUSH</code> + <code>LPOP</code>）命令实现消息队列。</p><p>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</p><p>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</p><p><strong>风险点：</strong></p><p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p><p>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p><p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><p>(2) 如何处理重复的消息？</p><p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p><ul><li>每个消息都有一个全局的 ID。</li><li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li></ul><p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p><p>(3) 如何保证消息可靠性？</p><p>当消费者程序从 <code>List</code> 中读取一条消息后，<code>List</code> 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 <code>List</code> 中读取消息了。</p><p>为了留存消息，<code>List</code> 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 <code>List</code> 中读取消息，同时，<code>Redis</code> 会把这个消息再插入到另一个 <code>List</code>（可以叫作备份 <code>List</code>）留存</strong>。</p><p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 <code>List</code> 中重新读取消息并进行处理了。</p><p>好了，到这里可以知道基于 <code>List</code> 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p><ul><li>消息保序：使用 <code>LPUSH</code> + <code>RPOP</code>；</li><li>阻塞读取：使用 <code>BRPOP</code>；</li><li>重复消息处理：生产者自行实现全局唯一 <code>ID</code>；</li><li>消息的可靠性：使用 <code>BRPOPLPUSH</code></li></ul><p>但是，<strong>在用 List 做消息队列时，如果生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力</strong>。</p><p>要解决这个问题，就要<strong>启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息</strong>。但是，<strong>List 类型并不支持消费组的实现</strong>。</p><p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p><h3 id="三、hash" tabindex="-1"><a class="header-anchor" href="#三、hash" aria-hidden="true">#</a> 三、<code>Hash</code></h3><p>Hash 是一个键值对（key - value）集合，其中 value 的形式入：<code>value=[{field1，value1}，...{fieldN，valueN}]</code>。Hash 特别适合用于存储对象。</p><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的，如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</p><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储一个哈希表key的键值</span>
HSET key field value

<span class="token comment"># 获取哈希表key对应的field键值</span>
HGET key field

<span class="token comment"># 在一个哈希表key中存储多个键值对</span>
HMSET key field value <span class="token punctuation">[</span>field value<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 批量获取哈希表key中多个field键值</span>
HMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>    
   
<span class="token comment"># 删除哈希表key中的field键值</span>
HDEL key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>    

<span class="token comment"># 返回哈希表key中field的数量</span>
HLEN key

<span class="token comment"># 返回哈希表key中所有的键值</span>
HGETALL key 

<span class="token comment"># 为哈希表key中field键的值加上增量n</span>
HINCRBY key field n           
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p>（1）缓存对象</p><p>（2）购物车</p><p>涉及的命令如下：</p><ul><li>添加商品：<code>HSET cart:{用户id} {商品id} 1</code></li><li>添加数量：<code>HINCRBY cart:{用户id} {商品id} 1</code></li><li>商品总数：<code>HLEN cart:{用户id}</code></li><li>删除商品：<code>HDEL cart:{用户id} {商品id}</code></li><li>获取购物车所有商品：<code>HGETALL cart:{用户id}</code></li></ul><h3 id="四、set-集合" tabindex="-1"><a class="header-anchor" href="#四、set-集合" aria-hidden="true">#</a> 四、<code>Set</code>（集合）</h3><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>Set 类型和 List 类型的区别如下：</p><ul><li><code>List</code> 可以存储重复元素，<code>Set</code> 只能存储非重复元素；</li><li><code>List</code> 是按照元素的先后顺序存储元素的，而 <code>Set</code> 则是无序方式存储元素的。</li></ul><p><code>Set</code> 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 <code>Redis</code> 使用<strong>哈希表</strong>作为 <code>Set</code> 类型的底层数据结构。</li></ul><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span>
SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 从集合key中删除元素</span>
SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span> 

<span class="token comment"># 获取集合key中所有元素</span>
SMEMBERS key

<span class="token comment"># 获取集合key中的元素个数</span>
SCARD key

<span class="token comment"># 判断member元素是否存在于集合key中</span>
SISMEMBER key member

<span class="token comment"># 从集合key中随机选出count个元素，元素不从key中删除</span>
SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>

<span class="token comment"># 从集合key中随机选出count个元素，元素从key中删除</span>
SPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>

<span class="token comment"># 运算操作</span>
<span class="token comment"># 交集运算</span>
SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 将交集结果存入新集合destination中</span>
SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 并集运算</span>
SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 将并集结果存入新集合destination中</span>
SUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 差集运算</span>
SDIFF key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 将差集结果存入新集合destination中</span>
SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p><p>因此 <code>Set</code> 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><p>但是要提醒你一下，这里有一个潜在的风险。<strong><code>Set</code> 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 <code>Redis</code> 实例阻塞</strong>。</p><p>在主从集群中，为了避免主库因为 <code>Set</code> 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><p>（1）点赞</p><p>（2）共同关注</p><p>（3）抽奖活动</p><h3 id="五、zset-有序集合" tabindex="-1"><a class="header-anchor" href="#五、zset-有序集合" aria-hidden="true">#</a> 五、<code>ZSet</code>（有序集合）</h3><p><code>Zset</code> 类型（有序集合类型）相比于 <code>Set</code> 类型多了一个排序属性 <code>score</code>（分值），对于有序集合 <code>ZSet</code> 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><p><code>Zset</code> 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 <code>Zset</code> 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 <code>Zset</code> 类型的底层数据结构；</li></ul><p>在 <code>Redis 7.0</code> 中，压缩列表数据结构已经废弃了，交由 <code>listpack</code> 数据结构来实现了。</p><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 往有序集合key中加入带分值元素</span>
ZADD key score member <span class="token punctuation">[</span><span class="token punctuation">[</span>score member<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>   

<span class="token comment"># 往有序集合key中删除元素</span>
ZREM key member <span class="token punctuation">[</span>member<span class="token punctuation">..</span>.<span class="token punctuation">]</span>                 

<span class="token comment"># 返回有序集合key中元素member的分值</span>
ZSCORE key member

<span class="token comment"># 返回有序集合key中元素个数</span>
ZCARD key 

<span class="token comment"># 为有序集合key中元素member的分值加上increment</span>
ZINCRBY key increment member 

<span class="token comment"># 正序获取有序集合key从start下标到stop下标的元素</span>
ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>

<span class="token comment"># 倒序获取有序集合key从start下标到stop下标的元素</span>
ZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>

<span class="token comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span>
ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>

<span class="token comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span>
ZRANGEBYLEX key min max <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>

<span class="token comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span>
ZREVRANGEBYLEX key max min <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>

<span class="token comment">#运算操作</span>
<span class="token comment"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
ZUNIONSTORE destkey numberkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> 

<span class="token comment"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
ZINTERSTORE destkey numberkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p><code>Zset</code> 类型（<code>Sorted Set</code>，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 <code>Sorted Set</code> 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p><p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 <code>Sorted Set</code>。</p><p>（1）排行榜</p><h3 id="六、bitmap-位图" tabindex="-1"><a class="header-anchor" href="#六、bitmap-位图" aria-hidden="true">#</a> 六、<code>Bitmap</code>（位图）</h3><p><code>Bitmap</code>，即位图，是一串连续的二进制数组（<code>0</code>和<code>1</code>），可以通过偏移量（<code>offset</code>）定位元素。<code>BitMap</code>通过最小的单位<code>bit</code>来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为<code>O(1)</code>。</p><p>由于 <code>bit</code> 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p><p><code>Bitmap</code> 本身是用 <code>String</code> 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p><code>String</code> 类型是会保存为二进制的字节数组，所以，<code>Redis</code> 就把字节数组的每个 <code>bit</code> 位利用起来，用来表示一个元素的二值状态，你可以把 <code>Bitmap</code> 看作是一个 <code>bit</code> 数组。</p><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置值，其中value只能是 0 和 1</span>
SETBIT key offset value

<span class="token comment"># 获取值</span>
GETBIT key offset

<span class="token comment"># 获取指定范围内值为 1 的个数</span>
<span class="token comment"># start 和 end 以字节为单位</span>
BITCOUNT key start end

<span class="token comment"># 运算</span>
<span class="token comment"># BitMap间的运算</span>
<span class="token comment"># operations 位移操作符，枚举值</span>
  AND 与运算 <span class="token operator">&amp;</span>
  OR 或运算 <span class="token operator">|</span>
  XOR 异或 ^
  NOT 取反 ~
  
<span class="token comment"># result 计算的结果，会存储在该key中</span>
<span class="token comment"># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span>
<span class="token comment"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span>
BITOP <span class="token punctuation">[</span>operations<span class="token punctuation">]</span> <span class="token punctuation">[</span>result<span class="token punctuation">]</span> <span class="token punctuation">[</span>key1<span class="token punctuation">]</span> <span class="token punctuation">[</span>keyn…<span class="token punctuation">]</span>

<span class="token comment"># 返回指定key中第一次出现指定value(0/1)的位置</span>
BITPOS <span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p><code>Bitmap</code> 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 <code>0</code> 和 <code>1</code> 两种，在记录海量数据时，<code>Bitmap</code> 能够有效地节省内存空间。</p><p>（1）签到统计</p><p>（2）判断用户登录</p><p><code>Bitmap</code> 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 <code>offset</code> 对 <code>bit</code> 数组的 <code>offset</code> 位置的 <code>bit</code> 位进行读写操作，需要注意的是 <code>offset</code> 从 <code>0</code> 开始。</p><p>只需要一个 <code>key = login_status</code> 表示存储用户登陆状态集合数据， 将用户 <code>ID</code> 作为 <code>offset</code>，在线就设置为 <code>1</code>，下线设置 <code>0</code>。通过 <code>GETBIT</code>判断对应的用户是否在线。<code>50000</code> 万 用户只需要 <code>6 MB</code> 的空间。</p><p>假如我们要判断 <code>ID = 10086</code> 的用户的登陆情况：</p><p>第一步，执行以下指令，表示用户已登录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GETBIT login_status <span class="token number">10086</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步，登出，将 offset 对应的 value 设置成 0。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（3）连续签到用户总数</p><p>如何统计出这连续 <code>7</code> 天连续打卡用户总数呢？</p><p>我们把每天的日期作为 <code>Bitmap</code> 的 <code>key</code>，<code>userId</code> 作为 <code>offset</code>，若是打卡则将 <code>offset</code> 位置的 <code>bit</code> 设置成 <code>1</code>。</p><p><code>key</code> 对应的集合的每个 <code>bit</code> 位的数据则是一个用户在该日期的打卡记录。</p><p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit = 1 就说明该用户 7 天连续打卡。</p><p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit = 1 的个数便得到了连续打卡 3 天的用户总数了。</p><p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p><ul><li><code>opration</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li></ul><p>举个例子，比如将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 与操作</span>
BITOP AND destmap bitmap:01 bitmap:02 bitmap:03

<span class="token comment"># 统计 bit 位 =  1 的个数</span>
BITCOUNT destmap
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使一天产生一个亿的数据，<code>Bitmap</code> 占用的内存也不大，大约占 <code>12 MB</code> 的内存<code>（10^8/8/1024/1024）</code>，<code>7</code> 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p><p>（4）统计用户的活跃天数</p><h3 id="七、hyperloglog" tabindex="-1"><a class="header-anchor" href="#七、hyperloglog" aria-hidden="true">#</a> 七、HyperLogLog</h3><p><code>Redis HyperLogLog</code> 是 <code>Redis 2.8.9</code> 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，<code>HyperLogLog</code> 是统计规则是基于概率完成的，不是非常准确，标准误算率是 <code>0.81%</code>。</p><p>所以，简单来说 <code>HyperLogLog</code> <strong>提供不精确的去重计数</strong>。</p><p><code>HyperLogLog</code> 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。</p><p>在 <code>Redis</code> 里面，<strong>每个 <code>HyperLogLog</code> 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>这什么概念？举个例子给大家对比一下。</p><p>用 Java 语言来说，一般 long 类型占用 8 字节，而 1 字节有 8 位，即：1 byte = 8 bit，即 long 数据类型最大可以表示的数是：<code>2^63-1</code>。对应上面的<code>2^64</code>个数，假设此时有<code>2^63-1</code>这么多个数，从 <code>0 ~ 2^63-1</code>，按照<code>long</code>以及<code>1k = 1024 字节</code>的规则来计算内存总数，就是：<code>((2^63-1) * 8/1024)K</code>，这是很庞大的一个数，存储空间远远超过<code>12K</code>，而 <code>HyperLogLog</code> 却可以用 <code>12K</code> 就能统计完。</p><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 添加指定元素到 HyperLogLog 中</span>
PFADD key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 返回给定 HyperLogLog 的基数估算值。</span>
PFCOUNT key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span>
PFMERGE destkey sourcekey <span class="token punctuation">[</span>sourcekey <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p>（1）百万级网页UV计数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 添加用户</span>
PFADD page1:uv user1 user2 user3 user4 user5

<span class="token comment"># 统计数目</span>
PFCOUNT page1:uv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="八、geo" tabindex="-1"><a class="header-anchor" href="#八、geo" aria-hidden="true">#</a> 八、GEO</h3><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p><p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p><p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p><p><strong>常用命令</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span>
GEOADD key longitude latitude member <span class="token punctuation">[</span>longitude latitude member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span>
GEOPOS key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 返回两个给定位置之间的距离。</span>
GEODIST key member1 member2 <span class="token punctuation">[</span>m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi<span class="token punctuation">]</span>

<span class="token comment"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span>
GEORADIUS key longitude latitude radius m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> <span class="token punctuation">[</span>ASC<span class="token operator">|</span>DESC<span class="token punctuation">]</span> <span class="token punctuation">[</span>STORE key<span class="token punctuation">]</span> <span class="token punctuation">[</span>STOREDIST key<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景</strong></p><p>（1）滴滴叫车</p><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p><p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p><p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GEOADD cars:locations <span class="token number">116.034579</span> <span class="token number">39.030452</span> <span class="token number">33</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p><p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GEORADIUS cars:locations <span class="token number">116.054579</span> <span class="token number">39.030452</span> <span class="token number">5</span> km ASC COUNT <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="九、stream" tabindex="-1"><a class="header-anchor" href="#九、stream" aria-hidden="true">#</a> 九、<code>Stream</code></h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在前面介绍 List 类型实现的消息队列，有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据。</p><p>基于 Stream 类型的消息队列就解决上面的问题，它不仅支持自动生成全局唯一 ID，而且支持以消费组形式消费数据。</p><p>Stream 消息队列操作命令：</p><ul><li><p>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</p></li><li><p>XREAD：用于读取消息，可以按 ID 读取数据；</p></li><li><p>XREADGROUP：按消费组形式读取消息；</p></li><li><p>XPENDING 和 XACK：</p><p>XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</p></li></ul><p>（1）Redis Stream 消息会丢失吗？</p><p>使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p><p>Redis Stream 消息队列能不能保证三个环节都不丢失数据？</p><ul><li><p>Redis 生产者会不会丢消息？生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</p></li><li><p>Redis 消费者会不会丢消息？不会，因为 Stream （ MQ 中间件）会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，但是未被确认的消息。消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。等到消费者执行完业务逻辑后，再发送消费确认 XACK 命令，也能保证消息的不丢失。</p></li><li><p>Redis 队列中间件会不会丢消息？<strong>会</strong>，Redis 在以下 2 个场景下，都会导致数据丢失：</p><ul><li><p>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</p></li><li><p>主从复制也是异步的，主从切换时，也存在丢失数据的可能。</p></li></ul></li><li><p>可以看到，Redis 在队列中间件环节无法保证消息不丢。像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</p></li></ul><p>（2）Redis Stream 消息可堆积吗？</p><ul><li><p>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。所以 Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p></li><li><p>但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上，当消息积压时，无非就是多占用一些磁盘空间。</p></li><li><p>因此，把 Redis 当作队列来使用时，会面临的 2 个问题：</p><ul><li><p>Redis 本身可能会丢数据；</p></li><li><p>面对消息挤压，内存资源会紧张；</p></li></ul></li><li><p>所以，能不能将 Redis 作为消息队列来使用，关键看你的业务场景：</p></li></ul><p>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</p><p>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</p><h2 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型" aria-hidden="true">#</a> 线程模型</h2><p><code>Redis</code> 基于 <code>Reactor</code> 模式开发了网络事件处理器，这个处理器被称为文本事件处理器。因为文件事件处理器队列消费是单线程的，所以 <code>Redis</code> 才叫单线程模型</p><p>文件事件处理器的结构：</p><ul><li><p>多个 <code>socket</code></p></li><li><p>IO 多路复用程序</p></li><li><p>文件事件分派器</p></li><li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复器）</p></li></ul><p><img src="/images/redis-thread-module.png" alt="Redis线程模型"></p><h3 id="一、消息处理流程" tabindex="-1"><a class="header-anchor" href="#一、消息处理流程" aria-hidden="true">#</a> 一、消息处理流程</h3><ul><li><p>文件事件处理器使用 <code>IO</code>多路复用（<code>multiplexing</code>）程序同时监听多个套接字，并根据套接字目前执行的任务类型为套接字关联不同的事件处理器</p></li><li><p>当被监听的套接字准备好执行应答（<code>accpect</code>）、读取（<code>read</code>）、写入（<code>write</code>）、关闭（<code>close</code>）等操作时，与之相对应的文件事件就会产生，这时文件事件处理器会调用套接字之前关联的好的事件处理器处理。</p></li></ul><p>虽然多个文件事件处理器并发出现， 但是 <code>IO</code>多路复用程序总是将所有产生事件的套接字推入同一个队列，通过该队列 <strong>有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式想文件事件分派器传送套接字</strong>。当上一个套接字产生的事件被处理完毕后（该套接字为事件所关联的事件处理器处理完毕），<code>IO</code>多路复用程序才向文件事件分派器传输下一个套接字。</p><h3 id="二、io多路复用的程序的实现" tabindex="-1"><a class="header-anchor" href="#二、io多路复用的程序的实现" aria-hidden="true">#</a> 二、IO多路复用的程序的实现</h3><p><code>Redis</code>的 <code>IO</code> 多路复用程序的所有功能是通过包装 <code>select</code>、<code>evport</code>、<code>epoll</code>、<code>kqueue</code> 这些多路复用的函数库实现的。每个 <code>IO</code> 多路复用的函数在 <code>Redis</code> 源码中都对应了一个单独的文件。如 <code>ae_select.c</code>、<code>ae_epoll.c</code>、<code>ae_kqueue.c</code>等。</p><p><img src="/images/redis-io.png" alt="Redis IO 多路复用"></p><p><code>Redis</code> 在 <code>IO</code> 多路复用程序的实现源码中，用 <code>#include</code> 宏定义了相关的规则，程序编译时自动选择系统中性能最好的 <code>IO</code>多路复用函数库来作为 <code>Redis</code> 的<code>IO</code>多路复用程序的底层实现。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Include the best multiplexing layer supported by this system.
 * The following should be ordered by performances, descending. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_EVPORT</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_evport.c&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_EPOLL</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_epoll.c&quot;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_KQUEUE</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_kqueue.c&quot;</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;ae_select.c&quot;</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三、文件事件的类型" tabindex="-1"><a class="header-anchor" href="#三、文件事件的类型" aria-hidden="true">#</a> 三、文件事件的类型</h3><p><code>IO</code> 多路复用程序可以监听多个套接字的 <code>ae.h/AE_READABLE</code> 事件和 <code>ae.h/AE_WRITABLE</code> 事件，这两类事件和套接字操作之间的关系如下：</p><ul><li><p>当套接字变得可读时（客户端对套接字执行 <code>write</code> 操作，或者执行 <code>close</code> 操作），或者有新的可应答（ <code>acceptable</code> ）套接字出现时（客户端对服务器的监听套接字执行 <code>connect</code> 操作），套接字产生 <code>AE_READABLE</code> 事件。</p></li><li><p>当套接字变得可写时（客户端对套接字执行 <code>read</code> 操作），套接字产生 <code>AE_WRITABLE</code> 事件。<code>I/O</code> 多路复用程序允许服务器同时监听套接字的 <code>AE_READABLE</code> 事件和 <code>AE_WRITABLE</code> 事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理 <code>AE_READABLE</code> 事件，等到 <code>AE_READABLE</code> 事件处理完之后，才处理 <code>AE_WRITABLE</code> 事件。这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</p></li></ul><h3 id="四、文件事件处理器" tabindex="-1"><a class="header-anchor" href="#四、文件事件处理器" aria-hidden="true">#</a> 四、文件事件处理器</h3><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通讯需求，常用的处理器如下：</p><ul><li><p>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。</p></li><li><p>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。</p></li><li><p>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</p></li></ul><h4 id="连接应答处理器" tabindex="-1"><a class="header-anchor" href="#连接应答处理器" aria-hidden="true">#</a> 连接应答处理器</h4><p><code>networking.c</code> 中 <code>acceptTcpHandler</code> 函数是 <code>Redis</code> 的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为 <code>sys/socket.h/accept</code> 函数的包装。当 <code>Redis</code> 服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的 <code>AE_READABLE</code> 事件关联起来，当有客户端用<code>sys/socket.h/connect</code> 函数连接服务器监听套接字的时候， 套接字就会产生<code>AE_READABLE</code> 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作</p><h4 id="命令请求处理器" tabindex="-1"><a class="header-anchor" href="#命令请求处理器" aria-hidden="true">#</a> 命令请求处理器</h4><p><code>networking.c</code> 中 <code>readQueryFromClient</code> 函数是 <code>Redis</code> 的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容， 具体实现为 <code>unistd.h/read</code> 函数的包装。当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的 <code>AE_READABLE</code> 事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生 <code>AE_READABLE</code> 事件，引发命令请求处理器执行，并执行相应的套接字读入操作，在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的 <code>AE_READABLE</code> 事件关联命令请求处理器。</p><h4 id="命令回复处理器" tabindex="-1"><a class="header-anchor" href="#命令回复处理器" aria-hidden="true">#</a> 命令回复处理器</h4><p><code>networking.c</code> 中 <code>sendReplyToClient</code> 函数是 <code>Redis</code> 的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为 <code>unistd.h/write</code> 函数的包装。当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的 <code>AE_WRITABLE</code> 事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生 <code>AE_WRITABLE</code> 事件，引发命令回复处理器执行，并执行相应的套接字写入操作，当命令回复发送完毕之后， 服务器就会解除命令回复处理器与客户端套接字的 <code>AE_WRITABLE</code> 事件之间的关联。</p><h3 id="五、一次客户端和-redis-的通信流程" tabindex="-1"><a class="header-anchor" href="#五、一次客户端和-redis-的通信流程" aria-hidden="true">#</a> 五、一次客户端和 <code>redis</code> 的通信流程</h3><h4 id="建立连接" tabindex="-1"><a class="header-anchor" href="#建立连接" aria-hidden="true">#</a> 建立连接</h4><ol><li><p><code>redis</code> 服务进程初始化时，将 <code>server socket</code> 的 <code>AE_READABLE</code> 事件与连接应答处理器关联</p></li><li><p>客户端 <code>socket01</code> 向 <code>redis</code> 进程 <code>sever socket</code> 请求建立连接，此时 <code>sever socket</code> 会产生一个 <code>AE_READABLE</code> 事件，<code>IO</code> 多路复用程序监听到 <code>server socket</code> 产生的事件后，将该 <code>socket01</code> 压入队列中</p></li><li><p>文件事件分派器从队列中获取 <code>socket01</code>，交给连接应答处理器</p></li><li><p>连接应答处理器会创建一个能与客户端通信的 <code>socket01</code> ，并将该 <code>socket</code> 的 <code>AE_READABLE</code> 的事件与请求应答处理器关联</p></li></ol><h4 id="执行请求" tabindex="-1"><a class="header-anchor" href="#执行请求" aria-hidden="true">#</a> 执行请求</h4><ol><li><p>客户端发送 <code>set key value</code> 的请求，此时 <code>redis</code> 的 <code>socket</code> 产生 <code>AE_READABLE</code>，<code>IO</code> 多路复用程序将 <code>socket</code> 压入队列</p></li><li><p>事件分派处理器获取到 <code>socket01</code> 产生的 <code>AE_READABLE</code> 事件，而在建立连接的过程中，已经将该 <code>socket</code> 的 <code>AE_READABLE</code> 事件，关联了请求应答处理器，由此交给请求应答处理器处理</p></li><li><p>请求应答处理器读取 <code>socket01</code> 的 <code>key value</code>, 并在自己的内存中完成 <code>key value</code> 的设置。</p></li><li><p>操作完成后，将 <code>socket01</code> 的 <code>AE_WRITABLE</code> 与 请求应答处理器关联</p></li><li><p>客户端准备好接受结果， <code>redis</code> 的 <code>socket01</code> 会产生一个 <code>AE_WRITABLE</code> 事件，并压入队列</p></li><li><p>事件分派器找到相关联的命令回复处理器，由命令回复处理器对 <code>socket01</code> 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 <code>socket01</code> 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</p></li></ol><p><img src="/images/redis-request-flow.png" alt="Redis请求流程"></p><h2 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h2><h3 id="一、linux-系统优化" tabindex="-1"><a class="header-anchor" href="#一、linux-系统优化" aria-hidden="true">#</a> 一、<code>Linux</code> 系统优化</h3><h4 id="ulimit-与-tcp-backlog" tabindex="-1"><a class="header-anchor" href="#ulimit-与-tcp-backlog" aria-hidden="true">#</a> <code>ulimit</code> 与 <code>TCP backlog</code></h4><p>1、修改 <code>ulimit</code></p><p>通过 <code>ulimit</code> 修改 <code>open files</code> 参数，<code>redis</code> 建议把 <code>open files</code> 至少设置成 <code>10032</code></p><blockquote><p><code>maxclients</code> 是 <code>10000</code>（客户端数据是以文本的形式进行保存的），<code>redis</code> 内部最多使用 <code>32 </code>个文件描述符。</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-n</span> <span class="token number">10032</span>  <span class="token comment">#但重启后就无效了，也可以通过配置文件limits.conf 的形式持久修改</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、修改 TCP backlog</p><p><code>redis</code> 默认的 <code>tcp-backlog</code> 为 <code>511</code>，可以通过调整 <code>tcp-backlog</code> 进行调整，若 <code>linux</code> 中的 <code>tcp-backlog</code> 小于 <code>redis</code> 的 <code>tcp-backlog</code>， 则日志会出现 <code>warning</code></p><blockquote><p>此参数确定了TCP连接中已完成队列（完成三次握手）的长度，此值必须小于或者等于 Linux 系统中定义的 <code>/proc/sys/net/core/somaxconn</code>， 而默认为 <code>128</code>，当系统并发量大并且客户端缓慢时，可考虑这两个参数一起设定。</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#建议修改为 2048 修改somaxconn</span>
<span class="token comment">#该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。</span>
<span class="token builtin class-name">echo</span> <span class="token number">2048</span> <span class="token operator">&gt;</span> /proc/sys/net/core/somaxconn <span class="token comment"># 但是这样系统重启后保存不了</span>

<span class="token comment">#持久化设置: 在 /etc/sysctl.conf 中添加如下:</span>
net.core.somaxconn <span class="token operator">=</span> <span class="token number">2048</span>

<span class="token comment">#然后在终端中执行:</span>
<span class="token function">sysctl</span> <span class="token parameter variable">-p</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="vm-overcommit-mermory-参数" tabindex="-1"><a class="header-anchor" href="#vm-overcommit-mermory-参数" aria-hidden="true">#</a> <code>vm.overcommit_mermory</code> 参数</h4><p><code>vm.overcommit_mermory</code> 表示内核在分配内存时做检查的方式。<code>Redis</code> 建议将 <code>vm.overcommit_memory</code> 取值设置为 <code>1</code>，防止极端情况下 <code>fork</code> 出错</p><p>取值说明：</p><ul><li><p><code>0</code> ：内核将检查是否有足够的内存，如果足够则通过，否则内存申请失败把错误返回给应用进程。</p></li><li><p><code>1</code> ：表示内核允许超量使用内存直到用完为止。</p></li><li><p><code>2</code> ：绝不过量使用内存，即整个内存空间不能超过 <code>swap</code> + <code>50%</code> 的 <code>RAM</code>，<code>50%</code> 是 <code>overcommit_ratio</code> 的默认值，支持修改。</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;vm.overcommit_memory=1&quot;</span> <span class="token operator">&gt;</span> /etc/sysctl.conf 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>Linux 对大多数申请内存的回复均为 YES，以运行更多程序，因为申请后并不是立马使用，该技术叫 <code>vm.overcommit</code>。</p></blockquote><h4 id="swappiness-参数" tabindex="-1"><a class="header-anchor" href="#swappiness-参数" aria-hidden="true">#</a> <code>swappiness</code> 参数</h4><p>该参数决定了操作系统使用 <code>swap</code> 的倾向程度，取值从 <code>0-100</code>, 值越大，说明操作系统使用 <code>swap</code> 的可能性越高，越低说明更倾向使用物理内存。</p><blockquote><p>若系统内存不足， 可能会将 <code>redis</code> 对应的某些页从内存 <code>swap</code> 到磁盘上，可以通过 <code>/proc</code> 文件夹中的 <code>smaps</code> 文件查看数据页是否有被 <code>swap</code>，若发现大量的页出现 <code>swap</code>, 可以通过 <code>vmstat</code> 和 <code>iostat</code> 进一步查看原因、</p></blockquote><p>（1）<code>Linux 3.5</code> 设置为<code>1</code>，其余设置为<code>0</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;vm.swappiness=1&quot;</span> <span class="token operator">&gt;</span> /etc/sysctl.conf 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="transparent-huge-pages" tabindex="-1"><a class="header-anchor" href="#transparent-huge-pages" aria-hidden="true">#</a> Transparent Huge Pages</h4><p>支持大内存分页（2MB）分配，默认为开启，Redis 建议关闭此功能</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">chkconfig</span> <span class="token parameter variable">--add</span> disable-transparent-hugepages
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="oom-killer" tabindex="-1"><a class="header-anchor" href="#oom-killer" aria-hidden="true">#</a> <code>OOM killer</code></h4><p>内存不足时选择性杀掉用户进程，<code>OOM Killer</code> 会为每一个用户进程设置一个权重，权重越大，被 <code>kill</code> 的可能性越大。每个进程的权重放在 <code>/proc/{progress_id}/oom_adj</code> , 可以将所有 <code>Redis</code> 的 <code>oom_adj</code> 设置为最低值或者较低值，降低被 <code>kill</code> 的值。</p><h3 id="二、redis-参数优化" tabindex="-1"><a class="header-anchor" href="#二、redis-参数优化" aria-hidden="true">#</a> 二、<code>Redis</code> 参数优化</h3><h4 id="maxclients" tabindex="-1"><a class="header-anchor" href="#maxclients" aria-hidden="true">#</a> <code>maxclients</code></h4><p>客户端最大连接数，如果连接数不够或者请求返回慢导致连接数不够，会报 <code>max number of clients reached</code></p><p><strong>调整 <code>maxclients</code> 最大连接数或者优化 <code>redis</code> 命令的处理性能。需要注意的是该参数受操作系统最大文件句柄的限制。</strong></p><h4 id="repl-ping-slave-period-repl-timeout" tabindex="-1"><a class="header-anchor" href="#repl-ping-slave-period-repl-timeout" aria-hidden="true">#</a> <code>repl-ping-slave-period/repl-timeout</code></h4><p><code>slave</code> 会每隔 <code>repl-ping-slave-period</code>（默认<code>10s</code>） <code>ping</code> 一次 <code>master</code>，若过了 <code>repl-timeout</code>（默认 <code>60s</code>）都没有收到响应，就会认为 <code>master</code> 挂了。</p><p><strong>若 <code>master</code> 阻塞也会报这个错，可以适当调整 <code>repl-timeout</code> 时间</strong></p><h4 id="client-output-buffer-limit" tabindex="-1"><a class="header-anchor" href="#client-output-buffer-limit" aria-hidden="true">#</a> <code>client-output-buffer-limit</code></h4><p>客户端输出缓冲区大小，当使用主从复制时，性能压测，数据量会急剧升高，导致从节点复制的数据量很大，耗时增长，<code>slave</code> 没挂但是被阻塞了，<code>master</code> 的指令不能直接发给 <code>slave</code> , 就会放到 <code>out-put buffer</code> 中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>client-output-buffer-limit slave 256mb 64mb <span class="token number">60</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述配置说明：负责发送给 <code>slave</code> 的 <code>client</code> ，如果 <code>buffer</code> 超过 <code>256m</code> 或者连续 <code>60</code> 秒超过 <code>64m</code>，就会被立刻强行关闭。所以此时应该相应调大数值，否则就会出现很悲剧的循环：<code>Master</code> 传输一个很大的 <code>RDB</code> 给 <code>slave</code> ，<code>slave</code> 努力地装载，但是还没装载完，<code>Master</code> 对 <code>client</code> 的缓存存满了，关闭后再来一次。</p><h3 id="四、慢查询语句" tabindex="-1"><a class="header-anchor" href="#四、慢查询语句" aria-hidden="true">#</a> 四、慢查询语句</h3><p><code>Redis</code> 提供了记录慢查询语句的功能，当语句执行（不包括排队时间）耗时超过了配置的阈值，则被认为是慢查询。</p><p><strong>配置项：</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 语句耗时的阈值，单位是微秒，1秒=1000毫秒=1000 000微妙，默认值：10000，当值为0时，记录所有请求，小于0不记录任何请求</span>
slowlog-log-slower-than 

<span class="token comment"># 记录慢查询的语句条数</span>
slowlog-max-len
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查询命令：</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查询慢查询信息</span>
slowlog get 

<span class="token comment"># 显示当前有多少条慢查询 </span>
slowlog len
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制" aria-hidden="true">#</a> 主从复制</h2><h2 id="cluster集群" tabindex="-1"><a class="header-anchor" href="#cluster集群" aria-hidden="true">#</a> cluster集群</h2><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h2><h2 id="事务机制" tabindex="-1"><a class="header-anchor" href="#事务机制" aria-hidden="true">#</a> 事务机制</h2><h2 id="故障排查" tabindex="-1"><a class="header-anchor" href="#故障排查" aria-hidden="true">#</a> 故障排查</h2><h2 id="淘汰策略与缓存机制" tabindex="-1"><a class="header-anchor" href="#淘汰策略与缓存机制" aria-hidden="true">#</a> 淘汰策略与缓存机制</h2><h2 id="大key风险和改造" tabindex="-1"><a class="header-anchor" href="#大key风险和改造" aria-hidden="true">#</a> 大key风险和改造</h2></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/totalo/website/edit/main/docs/README.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><!--]--> 在 GitHub 上编辑此页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: totalo@apache.org">totalo</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-51ae8744.js" defer></script>
  </body>
</html>
