# Java面试---语言基础

### equals 和 hashCode

equals相等的两个对象，hashcode一定相等。对于某些情况而言，hashcode有利于提高效率。一般是通过hashcode判断某个对象或者元素是否存在，存在再用equals判断。hashcode判断不存在了，则一定不存在。

### == 与 equals

== 比较的是内存地址。equals若不重写，底层也是==。重写后可以自行决定判断的属性等。

值类型即基本类型，使用==判断相等。

引用类型：==判断引用指向是否为同一个。equals方法，判断对象的等价性。

### 什么是面向对象以及如何理解面向对象（抽象 继承 多态 封装）

面向对象是一种思想，世界万物都可以看做一个对象，对于编程来说，即面向对象编程，Java是一个支持并发、基于类和面向对象的计算机编程语言，面向对象有如下优点:

1. 代码开发模块化，更容易修改和维护
2. 代码复用性强
3. 增强代码的可靠性和灵活性
4. 增加代码的可读性

封装

给对象提供隐藏内部特性和行为的能力，对象提供的供外部对象访问的方法改变它内部的数据。在Java中，有四种修饰符，default、public、private、protected。每一种权限修饰符为其他位于同一包或者不同包提供了不同的访问权限。封装的好处：

- 通过隐藏对象的属性来保护对象内部的状态。
- 提高了代码的可变性和维护性，因为对象的行为可以被单独改变或者拓展。
- 禁止对象之间的不良的交互提高模块化

继承

给对象提供了从基类获取字段和方法的能力，继承提供了代码重用行，也可以在不改变基类的情况下给现存的类添加新特性。

多态

编程语言给不同的底层数据类型做相同接口展示的一种能力，一个多态类型的操作，可以应用到其他类型的值上面。

抽象

把想法从具体的实例中分离出来的步骤，因此要根据他们的功能而不是实现细节来创建类。

Java支持创建只暴露接口而不包含具体实现的抽象类，这种抽象的技术将类的行为和实现细节分离。

**面向过程和面向对象的区别**

面向过程：

优点：性能比面向对象高，因为类调用需要实例化，开销比较大，比较消耗资源。

缺点：不易复用、拓展、维护

面向对象

优点：易于维护、拓展、复用，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活。

**重载和重写的区别**

1、重写Override

方法名、参数、返回值相同

子类不能缩小父类的访问权限

子类方法不能抛出比父类更多的异常

存在父类和子类之间

方法被定义为`final`不能重写

2、重载overload

参数类型、个数、顺序至少有一个不一样

不能重载只有返回值不一样的方法

存在父类、子类、同类中

### 深拷贝与浅拷贝

特指引用类型。

浅拷贝只是复制引用指针而不是复制对象，新旧对象还是共享同一块内存。深拷贝会复制一个对象和旧对象一样，不共享内存，不是指向同一个对象。

### Object 类有什么方法

registerNatives() 私有方法。

getClass() 返回此Object的运行类。

hashCode()返回对象的哈希值

equals(Object obj)用于确认两个对象是否相同

clone()创建并返回此对象的一个副本

toString()返回该对象的字符串表示

notify()唤醒此对象监视器上等待的单线程

notifyAll()唤醒在此对象监视器上等待的所有线程

wait(long timeout) 在其他线程调用对象的notify()或者notifyAll()方法，或者超过指定的时间前，导致当前线程等待。

wait(long timeout, int nanos) 在其他线程调用对象的notify()或者notifyAll()方法，或者超过指定的时间前，导致当前线程等待。

wait() 让当前线程失去操作权限，当前线程进入等待队列

finalize()当垃圾回收器确定不存在的对该对象的更多引用时，由对象的垃圾回收器调用此方法。

### String 的 intern() 方法

如果常量池中存在当前字符串则返回当前字符串，若不存在，将此字符串放入常量池中后返回。

### AQS 原理（todo）

### 各种锁的概念以及对比

- **自旋锁：**多线程同时访问同一个资源，为防止资源读取修改不一致设置的锁。如果线程访问资源时，已有线程占用资源，那么后者线程会等待当前线程释放资源，此时后者不休眠一直运行CPU检测前者占用资源是否释放。
- **互斥锁：**目的和自旋锁目的一样，但是机制不一样，当线程占用资源后，加上锁，后者线程访问时，由于资源占用，转入休眠状态，等待资源被释放后，通过信号量通知排队等候的线程。
- **乐观锁 ：**乐观锁假设认为数据一般情况下不会发生冲突，在数据提交更新时，才会正式对数据的冲突与否进行检测。
- **悲观锁：**和乐观锁相对，认为每次来都会冲突，提前加锁。
- **公平锁 **：保证每个线程都能拿到锁。
- **非公平锁**：不能保证每个线程都能拿到锁。
- **读写锁：**实际上是一种特殊的自旋锁，对共享资源的访问者划分为读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。相对传统的自旋锁而言，可以提高并发性，因为在多处理系统中，允许同时多个读者来访问共享资源。最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。在读写锁保持期间也是抢占失效的。
  如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。

### Java 锁升级流程

锁有四种状态，级别从低到高：无锁、偏向锁、轻量级锁、重量级锁

对象头部分为两部分信息，第一部分用来存储哈希码，GC分代年龄等，这部分数据被称为Mark Word，在32位的Hotspo虚拟机中对象未被锁定的情况下，Mark Word中32bit空间中25bit用来存储对象的哈希码，4bit用来存储对象分代年龄，2bit用来存储锁标记位，1bit固定为0，其他状态下对象存储的标志如下：

![](/images/lock-sin.png)

锁升级的方向：无锁->偏向锁->轻量级锁->重量级锁，且膨胀的方向不可逆。

1、偏向锁

偏向锁是JDK6中引入一项锁优化，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程获取，为让线程获得锁的代价更低，而引入了偏向锁。偏向锁会偏向第一个获取他的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程永远不需要同步。

2、轻量级锁

如果存在明显的其他线程申请锁，那么偏向锁将很快升级为轻量级锁。

3、自旋锁

如果持有锁的线程能在很短的时间内释放锁，那么等待锁竞争的线程就不需要做用户态和用户态之间的切换进入阻塞状态，他们只需要等一等，等持有锁的线程释放锁后立即获取锁，可以避免线程切换的消耗。

4、重量级锁

原始的synchronized实现，其他线程获取锁时都会被阻塞，只有持有锁的线程释放锁才能唤醒这些线程。
