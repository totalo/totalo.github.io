import{_ as e,p as d,q as r,a1 as a}from"./framework-204010b2.js";const o={},c=a('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="基础数据结构" tabindex="-1"><a class="header-anchor" href="#基础数据结构" aria-hidden="true">#</a> 基础数据结构</h2><h3 id="一、redis-的数据结构" tabindex="-1"><a class="header-anchor" href="#一、redis-的数据结构" aria-hidden="true">#</a> 一、<code>Redis</code> 的数据结构</h3><p>常见的五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p>后续新增：<strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong></p><h3 id="二、string-字符串" tabindex="-1"><a class="header-anchor" href="#二、string-字符串" aria-hidden="true">#</a> 二、<strong>String（字符串）</strong></h3><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <strong>512M</strong></p><p>底层数据结构主要是<strong>int</strong> 和<strong>SDS（简单动态字符串）</strong></p><p>SDS相对c原生字符串的优势：</p><ul><li><strong>SDS不仅仅可以保存文本数据，还可以保存二进制数据</strong>：因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong>：因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>：因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、raw和 embstr</strong>。</p><p>a、如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成 long），并将字符串对象的编码设置为<code>int</code>。</p><p>b、如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>embstr</code>， <code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式。</p><p>c、如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>raw</code></p><p>可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code></p><p>优点：</p><ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li><li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li><li><code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li></ul><p>缺点：</p><ul><li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</li></ul><p>应用场景</p><p>（1）缓存对象</p><p>（2）常规计数</p><p>（3）分布式锁</p><h2 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型" aria-hidden="true">#</a> 线程模型</h2><h2 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h2><h2 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制" aria-hidden="true">#</a> 主从复制</h2><h2 id="cluster集群" tabindex="-1"><a class="header-anchor" href="#cluster集群" aria-hidden="true">#</a> cluster集群</h2><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h2><h2 id="事务机制" tabindex="-1"><a class="header-anchor" href="#事务机制" aria-hidden="true">#</a> 事务机制</h2><h2 id="故障排查" tabindex="-1"><a class="header-anchor" href="#故障排查" aria-hidden="true">#</a> 故障排查</h2><h2 id="淘汰策略与缓存机制" tabindex="-1"><a class="header-anchor" href="#淘汰策略与缓存机制" aria-hidden="true">#</a> 淘汰策略与缓存机制</h2><h2 id="大key风险和改造" tabindex="-1"><a class="header-anchor" href="#大key风险和改造" aria-hidden="true">#</a> 大key风险和改造</h2><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2>',33),i=[c];function t(s,n){return d(),r("div",null,i)}const l=e(o,[["render",t],["__file","redis.html.vue"]]);export{l as default};
